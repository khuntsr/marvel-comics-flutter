 public class EncryptedRouteValueProvider : IValueProvider
    {
        private readonly RouteValueDictionary _values;

        public EncryptedRouteValueProvider(HttpContext httpContext)
        {
            _values = DecryptRouteValues(httpContext.GetRouteData().Values);
        }

        public bool ContainsPrefix(string prefix)
        {
            return _values.ContainsKey(prefix);
        }

        public ValueProviderResult GetValue(string key)
        {
            return _values.TryGetValue(key, out var value) ?
                new ValueProviderResult(Convert.ToString(value)) :
                ValueProviderResult.None;
        }

        private static RouteValueDictionary DecryptRouteValues(RouteValueDictionary encryptedValues)
        {
            var decryptedValues = new RouteValueDictionary();

            foreach (var kvp in encryptedValues)
            {
                switch (kvp.Value)
                {
                    case StringValues stringValues:
                        {
                            var decryptedValue = stringValues.Select(value => value?.Decrypt()).ToArray();
                            decryptedValues.Add(kvp.Key, new StringValues(decryptedValue));
                            break;
                        }
                    case string encryptedValue:
                        {
                            if (kvp.Key.Equals("area") || kvp.Key.Equals("action") || kvp.Key.Equals("controller"))
                                decryptedValues.Add(kvp.Key, kvp.Value);
                            else
                            {
                                var decryptedValue = encryptedValue.Decrypt();
                                decryptedValues.Add(kvp.Key, encryptedValue == decryptedValue ? string.Empty : decryptedValue);
                            }
                            break;
                        }
                    default:
                        decryptedValues.Add(kvp.Key, kvp.Value);
                        break;
                }
            }

            return decryptedValues;
        }
    }

    public class EncryptedRouteValueProviderFactory : IValueProviderFactory
    {
        public Task CreateValueProviderAsync(ValueProviderFactoryContext context)
        {
            var valueProvider = new EncryptedRouteValueProvider(context.ActionContext.HttpContext);
            context.ValueProviders.Add(valueProvider);
            return Task.CompletedTask;
        }
    }




using System.Text;
using System.Security.Cryptography;
using System.Web;

namespace CRM.Helpers
{
    /*
 *  This is a C# class named CryptoHelpers that provides encryption and decryption methods using AES (Advanced Encryption Standard). It includes the following methods:
    GetSecretKey() method: This method retrieves a secret key from an environment variable named "CryptographyKey".
    Encrypt(string plainText) method: This method encrypts the given plain text using the secret key obtained from the GetSecretKey() method, and returns the encrypted string after URL encoding it.
    Encrypt(string plainText, string secretKey) method: This method encrypts the given plain text using the given secret key, and returns the encrypted string after URL encoding it.
    AesEncryption(string plainText, string secretKey) method: This method is used by the above two Encrypt methods to perform the actual encryption. It takes the plain text and secret key as input and returns the encrypted string after encoding it in base64 format.
    Decrypt(string plainText) method: This method decrypts the given cipher text using the secret key obtained from the GetSecretKey() method, and returns the decrypted plain text.
    Decrypt(string plainText, string secretKey) method: This method decrypts the given cipher text using the given secret key, and returns the decrypted plain text.
    AesDecryption(string cipherText, string secretKey) method: This method is used by the above two Decrypt methods to perform the actual decryption. It takes the cipher text and secret key as input and returns the decrypted plain text after decoding it from base64 format.
    EncryptWithoutEncode(string plainText) method: This method encrypts the given plain text using the secret key obtained from the GetSecretKey() method, and returns the encrypted string in base64 format without URL encoding it.
    EncryptWithoutEncode(string plainText, string secretKey) method: This method encrypts the given plain text using the given secret key, and returns the encrypted string in base64 format without URL encoding it.
    DecryptWithoutEncode(string plainText) method: This method decrypts the given cipher text using the secret key obtained from the GetSecretKey() method, and returns the decrypted plain text without base64 decoding it.
    DecryptWithoutEncode(string plainText, string secretKey) method: This method decrypts the given cipher text using the given secret key, and returns the decrypted plain text without base64 decoding it.
    AesEncryptionWithoutEncode(string plainText, string secretKey) method: This method is used by the above two EncryptWithoutEncode methods to perform the actual encryption. It takes the plain text and secret key as input and returns the encrypted string in base64 format without URL encoding it.
    AesDecryptionWithoutEncode(string cipherText, string secretKey) method: This method is used by the above two DecryptWithoutEncode methods to perform the actual decryption. It takes the cipher text and secret key as input and returns the decrypted plain text without decoding it from base64 format.
 *
 */

    public static class CryptoHelpers
    {
        private static string GetSecretKey()
        {
            return Environment.GetEnvironmentVariable("CryptographyKey") ?? string.Empty;
        }

        public static string Encrypt(this string plainText)
        {
            return AesEncryption(plainText, GetSecretKey());
        }

        public static string Encrypt(this string plainText, string secretKey)
        {
            return AesEncryption(plainText, secretKey);
        }

        public static string AesEncryption(string plainText, string secretKey)
        {
            try
            {
                if (string.IsNullOrEmpty(plainText) || string.IsNullOrEmpty(secretKey))
                    return string.Empty;

                var clearBytes = Encoding.Unicode.GetBytes(plainText);
                using (var encrypt = Aes.Create())
                {
                    var pdb = new Rfc2898DeriveBytes(secretKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 }, 10, HashAlgorithmName.SHA512);
                    encrypt.Key = pdb.GetBytes(32);
                    encrypt.IV = pdb.GetBytes(16);

                    using var ms = new MemoryStream();

                    using (var cs = new CryptoStream(ms, encrypt.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(clearBytes, 0, clearBytes.Length);
                        cs.Close();
                    }
                    plainText = Convert.ToBase64String(ms.ToArray());
                }
                return HttpUtility.UrlEncode(plainText);
            }
            catch (Exception)
            {
                return plainText;
            }
        }

        public static string Decrypt(this string plainText)
        {
            return AesDecryption(plainText, GetSecretKey());
        }

        public static string Decrypt(this string plainText, string secretKey)
        {
            return AesDecryption(plainText, secretKey);
        }

        public static string AesDecryption(string cipherText, string secretKey)
        {
            try
            {
                if (string.IsNullOrEmpty(cipherText) || string.IsNullOrEmpty(secretKey))
                    return string.Empty;

                cipherText = HttpUtility.UrlDecode(cipherText);
                cipherText = cipherText.Replace(" ", "+");

                var cipherBytes = Convert.FromBase64String(cipherText);

                using var encrypt = Aes.Create();

                var pdb = new Rfc2898DeriveBytes(secretKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 }, 10, HashAlgorithmName.SHA512);
                encrypt.Key = pdb.GetBytes(32);
                encrypt.IV = pdb.GetBytes(16);

                using var ms = new MemoryStream();
                using (var cs = new CryptoStream(ms, encrypt.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cs.Write(cipherBytes, 0, cipherBytes.Length);
                    cs.Close();
                }
                cipherText = Encoding.Unicode.GetString(ms.ToArray());

                return cipherText;
            }
            catch (Exception)
            {
                return cipherText;
            }
        }

        public static string EncryptWithoutEncode(this string plainText)
        {
            return AesEncryptionWithoutEncode(plainText, GetSecretKey());
        }

        public static string EncryptWithoutEncode(this string plainText, string secretKey)
        {
            return AesEncryptionWithoutEncode(plainText, secretKey);
        }

        public static string DecryptWithoutEncode(this string plainText)
        {
            return AesDecryptionWithoutEncode(plainText, GetSecretKey());
        }

        public static string DecryptWithoutEncode(this string plainText, string secretKey)
        {
            return AesDecryptionWithoutEncode(plainText, secretKey);
        }

        private static string AesEncryptionWithoutEncode(this string plainText, string secretKey)
        {
            if (string.IsNullOrEmpty(plainText) || string.IsNullOrEmpty(secretKey))
                return string.Empty;

            var clearBytes = Encoding.Unicode.GetBytes(plainText);
            using var encrypt = Aes.Create();

            var pdb = new Rfc2898DeriveBytes(secretKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 }, 10, HashAlgorithmName.SHA512);
            encrypt.Key = pdb.GetBytes(32);
            encrypt.IV = pdb.GetBytes(16);

            using var ms = new MemoryStream();

            using (var cs = new CryptoStream(ms, encrypt.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearBytes, 0, clearBytes.Length);
                cs.Close();
            }
            plainText = Convert.ToBase64String(ms.ToArray());
            return plainText;
        }

        private static string AesDecryptionWithoutEncode(this string cipherText, string secretKey)
        {

            if (string.IsNullOrEmpty(cipherText) || string.IsNullOrEmpty(secretKey))
                return string.Empty;

            cipherText = cipherText.Replace(" ", "+");

            var cipherBytes = Convert.FromBase64String(cipherText);

            using var encrypt = Aes.Create();

            var pdb = new Rfc2898DeriveBytes(secretKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 }, 10, HashAlgorithmName.SHA512);
            encrypt.Key = pdb.GetBytes(32);
            encrypt.IV = pdb.GetBytes(16);

            using var ms = new MemoryStream();
            using (var cs = new CryptoStream(ms, encrypt.CreateDecryptor(), CryptoStreamMode.Write))
            {
                cs.Write(cipherBytes, 0, cipherBytes.Length);
                cs.Close();
            }
            cipherText = Encoding.Unicode.GetString(ms.ToArray());

            return cipherText;
        }
    }
}


  builder.Services.AddMvc(options =>
    {
        options.ValueProviderFactories.Insert(0, new EncryptedRouteValueProviderFactory());
    });
